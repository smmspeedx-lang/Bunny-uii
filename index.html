 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PRO Prediction System</title>
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
        rel="stylesheet"
    />

    <style>
        /* [All previous CSS styles remain exactly the same] */
        :root {
            --primary: #890DF7;
            --primary-dark: #FC00FF;
            --primary-light: #4caf50;
            --secondary: #1565c0;
            --secondary-dark: #0d47a1;
            --text-primary: #212121;
            --text-secondary: #757575;
            --background: #f8f9fa;
            --card-bg: #ffffff;
            --border: #e0e0e0;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --gradient-primary: linear-gradient(135deg, var(--primary), var(--primary-dark));
            --gradient-secondary: linear-gradient(135deg, var(--secondary), var(--secondary-dark));
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Inter", sans-serif;
            background-color: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            padding-bottom: 90px;
        }

        .container {
            width: 100%;
            max-width: 500px;
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: var(--shadow);
            overflow: hidden;
            border: 1px solid var(--border);
            transition: transform 0.3s ease;
        }

        .container:hover {
            transform: translateY(-5px);
        }

        .header {
            background: var(--gradient-primary);
            color: white;
            padding: 28px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
            pointer-events: none;
        }

        .header h1 {
            font-size: 26px;
            font-weight: 700;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            position: relative;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 300;
            position: relative;
        }

        .header-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 28px;
            opacity: 0.8;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        .content {
            padding: 28px;
        }

        .tab {
            display: none;
        }

        .tab.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .info-card {
            background: #f5f9ff;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 28px;
            border-left: 4px solid var(--secondary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }

        .info-card:hover {
            transform: translateY(-3px);
        }

        .info-title {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }

        .info-title i {
            color: var(--secondary);
            margin-right: 10px;
            font-size: 20px;
        }

        .info-title h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .period-display {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
        }

        .period-id {
            font-size: 16px;
            color: var(--text-secondary);
            font-family: monospace;
            background: rgba(0, 0, 0, 0.04);
            padding: 6px 12px;
            border-radius: 8px;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .countdown-section {
            text-align: center;
            margin: 36px 0;
            padding: 20px;
            background: rgba(46, 125, 50, 0.05);
            border-radius: 16px;
            border: 1px solid rgba(46, 125, 50, 0.1);
        }

        .countdown-label {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .countdown {
            font-size: 48px;
            font-weight: 700;
            color: var(--primary);
            letter-spacing: 2px;
            font-variant-numeric: tabular-nums;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .prediction-section {
            background: var(--gradient-primary);
            border-radius: 16px;
            padding: 28px 20px;
            text-align: center;
            margin-top: 24px;
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 8px 20px rgba(46, 125, 50, 0.2);
            color: white;
            position: relative;
            overflow: hidden;
        }

        .prediction-section::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
            pointer-events: none;
        }

        .prediction-label {
            font-size: 16px;
            opacity: 0.9;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
        }

        .prediction-result {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 12px;
            position: relative;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .accuracy {
            font-size: 18px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            position: relative;
            backdrop-filter: blur(5px);
        }

        .footer {
            text-align: center;
            padding: 20px 20px 22px;
            font-size: 14px;
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(0,0,0,0.02);
        }

        .text-sm {
            font-size: 0.85rem;
        }

        .text-muted {
            color: var(--text-secondary);
        }

        /* BOTTOM NAV - FLOATING BUBBLE STYLE */
        .bottom-nav {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 10px 16px 16px;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }

        .bottom-nav-inner {
            background: rgba(255, 255, 255, 0.96);
            border-radius: 999px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            padding: 8px;
            display: flex;
            gap: 8px;
            pointer-events: auto;
            border: 1px solid rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(10px);
        }

        .nav-item {
            border: none;
            outline: none;
            background: transparent;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 18px;
            border-radius: 999px;
            cursor: pointer;
            transition:
                transform 0.25s ease,
                box-shadow 0.25s ease,
                background 0.25s ease,
                color 0.25s ease;
            font-size: 12px;
            position: relative;
        }

        .nav-icon {
            font-size: 20px;
            margin-bottom: 4px;
            transition: transform 0.25s ease;
        }

        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }

        .nav-item.active {
            background: var(--gradient-primary);
            color: #ffffff;
            transform: translateY(-6px);
            box-shadow: 0 10px 20px rgba(21, 101, 192, 0.35);
        }

        .nav-item.active .nav-icon {
            transform: translateY(-2px);
        }

        .nav-item:active {
            transform: translateY(-2px) scale(0.96);
        }

        /* History Tab Styles */
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .clear-history-btn {
            background: var(--gradient-secondary);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(21, 101, 192, 0.2);
        }

        .clear-history-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(21, 101, 192, 0.3);
        }

        .clear-history-btn:active {
            transform: translateY(0);
        }

        .history-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .history-list::-webkit-scrollbar {
            width: 6px;
        }

        .history-list::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }

        .history-list::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
        }

        .history-item {
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 12px;
            background: white;
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .history-item.pending {
            border-left: 4px solid var(--warning);
        }

        .history-item.win {
            border-left: 4px solid var(--success);
        }

        .history-item.loss {
            border-left: 4px solid var(--error);
        }

        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .history-period {
            font-weight: 600;
            font-size: 16px;
        }

        .history-status {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 20px;
        }

        .history-status.pending {
            background: rgba(255, 152, 0, 0.1);
            color: var(--warning);
        }

        .history-status.win {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
        }

        .history-status.loss {
            background: rgba(244, 67, 54, 0.1);
            color: var(--error);
        }

        .history-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 14px;
        }

        .history-detail-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .history-detail-label {
            color: var(--text-secondary);
        }

        .history-detail-value {
            font-weight: 500;
        }

        .empty-history {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-history i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-history p {
            font-size: 16px;
        }

        /* Bot Configuration Styles */
        .config-section {
            margin-bottom: 24px;
        }

        .config-group {
            margin-bottom: 20px;
        }

        .config-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .config-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            background: white;
            transition: all 0.3s ease;
        }

        .config-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.1);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
        }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: 0 4px 12px rgba(46, 125, 50, 0.2);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(46, 125, 50, 0.3);
        }

        .btn-secondary {
            background: var(--gradient-secondary);
            color: white;
            box-shadow: 0 4px 12px rgba(21, 101, 192, 0.2);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(21, 101, 192, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error), #d32f2f);
            color: white;
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.2);
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(244, 67, 54, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1) !important;
        }

        .status-indicator {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 16px;
        }

        .status-active {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
            border: 1px solid rgba(76, 175, 80, 0.2);
        }

        .status-inactive {
            background: rgba(158, 158, 158, 0.1);
            color: var(--text-secondary);
            border: 1px solid rgba(158, 158, 158, 0.2);
        }

        .session-info {
            background: rgba(33, 150, 243, 0.05);
            border: 1px solid rgba(33, 150, 243, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .session-info h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--secondary);
        }

        .session-info p {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .error-message {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.2);
            color: var(--error);
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        .success-message {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.2);
            color: var(--success);
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        .setup-guide {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .setup-guide h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--warning);
        }

        .setup-guide ol {
            padding-left: 20px;
            margin-bottom: 12px;
        }

        .setup-guide li {
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .setup-guide code {
            background: rgba(0,0,0,0.05);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        @media (max-width: 480px) {
            .container {
                border-radius: 16px;
            }

            .header {
                padding: 24px 16px;
            }

            .header h1 {
                font-size: 22px;
            }

            .content {
                padding: 24px 16px;
            }

            .countdown {
                font-size: 40px;
            }

            .prediction-result {
                font-size: 32px;
            }

            .bottom-nav-inner {
                width: 100%;
                max-width: 380px;
                justify-content: space-between;
            }

            .history-details {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<!-- PASSWORD MODAL (paste before </body>) -->
<div id="pw-overlay" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:9999;">
  <div style="width:320px;background:#fff;border-radius:12px;padding:20px;box-shadow:0 8px 30px rgba(0,0,0,0.3);text-align:center;font-family:Inter, sans-serif;">
    <h3 style="margin-bottom:8px;">Enter Password</h3>
    <input id="pw-input" type="password" placeholder="Password" style="width:100%;padding:10px;border-radius:8px;border:1px solid #ddd;margin-bottom:12px;font-size:14px;">
    <div style="display:flex;gap:8px;">
      <button id="pw-ok" style="flex:1;padding:10px;border-radius:8px;border:none;background:linear-gradient(135deg,#890DF7,#FC00FF);color:#fff;font-weight:600;cursor:pointer;">Go</button>
      <button id="pw-cancel" style="padding:10px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer;">Cancel</button>
    </div>
    <p id="pw-msg" style="color:#e53935;margin-top:10px;display:none;font-size:13px;"></p>
  </div>
</div>

<script>
  (function(){
    // CHANGE THIS to your password (plaintext here ‚Äî client-side only)
    const CORRECT = "1234"; // change to desired password

    const overlay = document.getElementById("pw-overlay");
    const input = document.getElementById("pw-input");
    const ok = document.getElementById("pw-ok");
    const cancel = document.getElementById("pw-cancel");
    const msg = document.getElementById("pw-msg");

    // autofocus
    input.focus();

    ok.addEventListener("click", tryPass);
    input.addEventListener("keydown", function(e){ if(e.key === "Enter") tryPass(); });
    cancel.addEventListener("click", function(){
      msg.style.display = "none";
      input.value = "";
      // optional: hide overlay or keep it ‚Äî here we keep it
    });

    function tryPass(){
      const val = input.value || "";
      if(val === CORRECT){
        // success -> redirect to next page
        overlay.style.display = "none";
        // redirect (change to whatever page you want)
        window.location.href = "next.html";
      } else {
        msg.style.display = "block";
        msg.textContent = "Incorrect password ‚Äî try again.";
      }
    }
  })();
</script>
<body>
<div class="container">
    <div class="header">
        <i class="header-icon fas fa-chart-line"></i>
        <h1> BUNNY 1.0</h1>
        <p>Advanced AI-Powered Forecasting</p>
    </div>

    <div class="content">
        <!-- HOME TAB -->
        <div id="tab-home" class="tab active">
            <!-- CURRENT PERIOD -->
            <div class="info-card">
                <div class="info-title">
                    <i class="fas fa-clock"></i>
                    <h2>Current Period</h2>
                </div>
                <div class="period-display">
                    Period: <span class="period-id" id="period">Loading...</span>
                </div>
            </div>

            <!-- COUNTDOWN -->
            <div class="countdown-section">
                <div class="countdown-label">
                    <i class="fas fa-hourglass-half"></i>
                    Next Prediction In
                </div>
                <div class="countdown" id="countdown">00:00</div>
            </div>

            <!-- PREDICTION BOX -->
            <div class="prediction-section">
                <div class="prediction-label">
                    <i class="fas fa-bullseye"></i>
                    Prediction Result
                </div>
                <div class="prediction-result" id="resultBox">Waiting...</div>
                <div class="accuracy" id="accuracy">--% accuracy</div>
            </div>
        </div>

        <!-- HISTORY TAB -->
        <div id="tab-history" class="tab">
            <div class="history-header">
                <div class="info-title">
                    <i class="fas fa-history"></i>
                    <h2>Prediction History</h2>
                </div>
                <button class="clear-history-btn" id="clearHistoryBtn">
                    <i class="fas fa-trash-alt"></i>
                    Clear History
                </button>
            </div>
            
            <div class="history-list" id="historyList">
                <div class="empty-history">
                    <i class="fas fa-history"></i>
                    <p>No predictions yet</p>
                </div>
            </div>
        </div>

        <!-- BOT TAB -->
        <div id="tab-bot" class="tab">
            <div class="info-title">
                <i class="fas fa-robot"></i>
                <h2>Telegram Bot Configuration</h2>
            </div>

            <!-- Messages -->
            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>

            <!-- Setup Guide -->
            <div class="setup-guide">
                <h3>üìã Setup Instructions</h3>
                <ol>
                    <li>Create a bot with <code>@BotFather</code> on Telegram</li>
                    <li>Copy the bot token (format: <code>1234567890:ABCdefGHIjklMNopQRstUVwxYZ</code>)</li>
                    <li>Create a channel and add your bot as admin</li>
                    <li>For private channels: Send a message, then use <code>@getidsbot</code> to get Channel ID</li>
                    <li>For public channels: Use <code>@channelname</code></li>
                </ol>
            </div>

            <!-- Session Status -->
            <div class="session-info">
                <h3>Session Status</h3>
                <div class="status-indicator" id="sessionStatus">INACTIVE</div>
                <p id="sessionStats">Predictions Sent: 0 | Wins: 0 | Losses: 0</p>
            </div>

            <!-- Bot Configuration -->
            <div class="config-section">
                <div class="config-group">
                    <label class="config-label">Telegram Bot Token</label>
                    <input type="text" class="config-input" id="botToken" placeholder="1234567890:ABCdefGHIjklMNopQRstUVwxYZ">
                    <small style="color: var(--text-secondary); font-size: 12px; margin-top: 4px; display: block;">
                        Get this from @BotFather - must contain numbers, colon, and letters
                    </small>
                </div>

                <div class="config-group">
                    <label class="config-label">Telegram Channel ID</label>
                    <input type="text" class="config-input" id="channelId" placeholder="@channelname or -1001234567890">
                    <small style="color: var(--text-secondary); font-size: 12px; margin-top: 4px; display: block;">
                        Public: @channelname | Private: -1001234567890 (use @getidsbot to find)
                    </small>
                </div>

                <div class="toggle-container">
                    <label class="toggle-switch">
                        <input type="checkbox" id="enableCustomButton">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="toggle-label">Enable Custom Button</span>
                </div>

                <div id="customButtonConfig" style="display: none;">
                    <div class="config-group">
                        <label class="config-label">Button Title</label>
                        <input type="text" class="config-input" id="buttonTitle" placeholder="Join Now">
                    </div>
                    <div class="config-group">
                        <label class="config-label">Button URL</label>
                        <input type="text" class="config-input" id="buttonUrl" placeholder="https://example.com">
                    </div>
                </div>

                <button class="btn btn-primary" id="saveConfigBtn">
                    <i class="fas fa-save"></i>
                    Save Configuration
                </button>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-secondary" id="startSessionBtn">
                    <i class="fas fa-play"></i>
                    Start Session
                </button>
                <button class="btn btn-danger" id="endSessionBtn" disabled>
                    <i class="fas fa-stop"></i>
                    End Session
                </button>
            </div>

            <!-- Test Connection -->
            <div class="config-section">
                <button class="btn btn-primary" id="testConnectionBtn" style="background: var(--gradient-secondary);">
                    <i class="fas fa-wifi"></i>
                    Test Connection
                </button>
            </div>
        </div>
    </div>

    <div class="footer">
        <i class="fas fa-brain"></i>
        Powered by @bunnytreding AI Logic ‚Ä¢ UTC Based
    </div>
</div>

<!-- BOTTOM NAV -->
<div class="bottom-nav">
    <div class="bottom-nav-inner">
        <button class="nav-item active" data-tab="tab-home">
            <span class="nav-icon"><i class="fas fa-home"></i></span>
            <span class="nav-label">Home</span>
        </button>
        <button class="nav-item" data-tab="tab-history">
            <span class="nav-icon"><i class="fas fa-history"></i></span>
            <span class="nav-label">History</span>
        </button>
        <button class="nav-item" data-tab="tab-bot">
            <span class="nav-icon"><i class="fas fa-robot"></i></span>
            <span class="nav-label">Bot</span>
        </button>
    </div>
</div>

<script>
    //---------------------------------------------------
    //  GLOBAL STATE
    //---------------------------------------------------
    let displayPeriod = "";
    let lastResults = { bigsmall: [] };
    let isSessionActive = false;
    let sessionStats = { predictions: 0, wins: 0, losses: 0 };
    let botConfig = {
        token: '',
        channelId: '',
        customButton: { enabled: false, title: '', url: '' }
    };

    let predictionHistory = JSON.parse(localStorage.getItem('predictionHistory')) || [];
    let hasPendingVerification = false;
    let lastSecond = null;

    //---------------------------------------------------
    //  UTILITY FUNCTIONS
    //---------------------------------------------------
    function showMessage(message, type = 'error') {
        const errorElement = document.getElementById('errorMessage');
        const successElement = document.getElementById('successMessage');
        
        if (type === 'error') {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            successElement.style.display = 'none';
        } else {
            successElement.textContent = message;
            successElement.style.display = 'block';
            errorElement.style.display = 'none';
        }
        
        setTimeout(() => {
            errorElement.style.display = 'none';
            successElement.style.display = 'none';
        }, 5000);
    }

    function validateBotToken(token) {
        if (!token) return false;
        // Bot token format: 1234567890:ABCdefGHIjklMNopQRstUVwxYZ
        return /^\d{8,11}:[A-Za-z0-9_-]{35}$/.test(token);
    }

    function validateChannelId(channelId) {
        if (!channelId) return false;
        // Public: @channelname, Private: -1001234567890
        return channelId.startsWith('@') || (channelId.startsWith('-100') && channelId.length > 10);
    }

    //---------------------------------------------------
    //  TELEGRAM BOT FUNCTIONS (SIMPLIFIED AND FIXED)
    //---------------------------------------------------
    async function sendTelegramMessage(text, options = {}) {
        if (!botConfig.token || !botConfig.channelId) {
            throw new Error('Bot token or channel ID not configured');
        }

        if (!validateBotToken(botConfig.token)) {
            throw new Error('Invalid bot token format');
        }

        if (!validateChannelId(botConfig.channelId)) {
            throw new Error('Invalid channel ID format');
        }

        const params = {
            chat_id: botConfig.channelId,
            text: text,
            parse_mode: 'HTML',
            disable_web_page_preview: true
        };

        // Add reply markup if provided
        if (options.reply_markup) {
            params.reply_markup = JSON.stringify(options.reply_markup);
        }

        const telegramUrl = `https://api.telegram.org/bot${botConfig.token}/sendMessage`;
        
        try {
            // Use URLSearchParams for simple text messages
            const urlParams = new URLSearchParams();
            Object.keys(params).forEach(key => {
                urlParams.append(key, params[key]);
            });

            const response = await fetch(telegramUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: urlParams
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.description || `HTTP ${response.status}`);
            }

            const result = await response.json();
            return result.ok;
            
        } catch (error) {
            console.error('Telegram API error:', error);
            
            // Try with CORS proxy as fallback
            try {
                const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(telegramUrl);
                const urlParams = new URLSearchParams();
                Object.keys(params).forEach(key => {
                    urlParams.append(key, params[key]);
                });

                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: urlParams
                });

                if (!response.ok) {
                    throw new Error(`Proxy HTTP ${response.status}`);
                }

                const result = await response.json();
                return result.ok;
                
            } catch (proxyError) {
                console.error('Proxy also failed:', proxyError);
                throw new Error(`Failed to send message: ${error.message}`);
            }
        }
    }

    async function sendTelegramSticker(stickerId) {
        if (!botConfig.token || !botConfig.channelId) return false;

        const params = {
            chat_id: botConfig.channelId,
            sticker: stickerId
        };

        const telegramUrl = `https://api.telegram.org/bot${botConfig.token}/sendSticker`;
        
        try {
            const urlParams = new URLSearchParams();
            Object.keys(params).forEach(key => {
                urlParams.append(key, params[key]);
            });

            const response = await fetch(telegramUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: urlParams
            });

            return response.ok;
        } catch (error) {
            console.error('Failed to send sticker:', error);
            return false;
        }
    }

    async function testTelegramConnection() {
        if (!botConfig.token || !botConfig.channelId) {
            throw new Error('Please configure bot token and channel ID first');
        }

        // Test by sending a simple message
        const testMessage = 'ü§ñ <b>Connection Test</b>\n\n‚úÖ Bot is working correctly!\n\nThis is a test message from Treding Vision AI.';
        
        try {
            const success = await sendTelegramMessage(testMessage);
            
            if (success) {
                return '‚úÖ Connection successful! Test message sent to your channel.';
            } else {
                throw new Error('Failed to send test message');
            }
        } catch (error) {
            throw new Error('Connection test failed: ' + error.message);
        }
    }

    //---------------------------------------------------
    //  INITIALIZATION
    //---------------------------------------------------
    function initializeApp() {
        const savedConfig = localStorage.getItem('botConfig');
        if (savedConfig) {
            botConfig = JSON.parse(savedConfig);
            document.getElementById('botToken').value = botConfig.token || '';
            document.getElementById('channelId').value = botConfig.channelId || '';
            document.getElementById('enableCustomButton').checked = botConfig.customButton.enabled;
            document.getElementById('buttonTitle').value = botConfig.customButton.title || '';
            document.getElementById('buttonUrl').value = botConfig.customButton.url || '';
            
            toggleCustomButtonConfig();
        }

        const savedStats = localStorage.getItem('sessionStats');
        if (savedStats) {
            sessionStats = JSON.parse(savedStats);
            updateSessionStats();
        }

        isSessionActive = localStorage.getItem('isSessionActive') === 'true';
        updateSessionUI();
    }

    //---------------------------------------------------
    //  BOT CONFIGURATION
    //---------------------------------------------------
    function toggleCustomButtonConfig() {
        const configDiv = document.getElementById('customButtonConfig');
        configDiv.style.display = document.getElementById('enableCustomButton').checked ? 'block' : 'none';
    }

    function saveBotConfig() {
        botConfig = {
            token: document.getElementById('botToken').value.trim(),
            channelId: document.getElementById('channelId').value.trim(),
            customButton: {
                enabled: document.getElementById('enableCustomButton').checked,
                title: document.getElementById('buttonTitle').value.trim(),
                url: document.getElementById('buttonUrl').value.trim()
            }
        };

        if (!validateBotToken(botConfig.token)) {
            showMessage('Invalid bot token format. Should be like: 1234567890:ABCdefGHIjklMNopQRstUVwxYZ');
            return;
        }

        if (!validateChannelId(botConfig.channelId)) {
            showMessage('Invalid channel ID. Should start with @ for public channels or -100 for private channels');
            return;
        }

        localStorage.setItem('botConfig', JSON.stringify(botConfig));
        showMessage('Configuration saved successfully!', 'success');
    }

//---------------------------------------------------
//  SEND PHOTO FUNCTION
//---------------------------------------------------
async function sendTelegramPhoto(photoUrl, caption) {
    try {
        const url = `https://api.telegram.org/bot${botConfig.token}/sendPhoto`;

        const response = await fetch(url, {
            method: "POST",
            body: JSON.stringify({
                chat_id: botConfig.channelId,
                photo: photoUrl,
                caption: caption,
                parse_mode: "HTML"
            }),
            headers: {
                "Content-Type": "application/json"
            }
        });

        const result = await response.json();
        return result.ok;
    } catch (error) {
        return false;
    }
}

//---------------------------------------------------
//  SESSION MANAGEMENT (WITH IMAGE)
//---------------------------------------------------

async function startSession() {
    if (!botConfig.token || !botConfig.channelId) {
        showMessage('Please configure bot token and channel ID first!');
        return;
    }

    try {
        const caption =
                'üü¢ <b>‚åØ SESSION STARTED ‚åØ üü¢</b> \n' +
                ' <b>‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>\n' +
                '‚û† Platform: WinGo Pro\n' +
                '‚û† Server: Premium Server\n' +
                '‚û† Wingo: 1 Minute\n' +            ' ‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n' +
                
               '‚åØ ùòöùòµùò¢ùò∫ ùòµùò∂ùòØùò¶ùò• ùòßùò∞ùò≥ ùòàùòê-ùò±ùò∞ùò∏ùò¶ùò≥ùò¶ùò• ùò±ùò≥ùò¶ùò•ùò™ùò§ùòµùò™ùò∞ùòØùò¥ ‚åØ '
               ;
                
        const success = await sendTelegramPhoto(
            "https://i.ibb.co/tTYW8t1b/Picsart-25-11-23-19-23-43-631.png",
            caption
        );

        if (success) {
            isSessionActive = true;
            sessionStats = { predictions: 0, wins: 0, losses: 0 };
            localStorage.setItem('isSessionActive', 'true');
            localStorage.setItem('sessionStats', JSON.stringify(sessionStats));
            updateSessionUI();
            showMessage('Session started successfully! Predictions will be sent to your Telegram channel.', 'success');
        } else {
            throw new Error('Failed to send start message');
        }
    } catch (error) {
        showMessage('Failed to start session: ' + error.message);
    }
}

async function endSession() {
    if (!isSessionActive) return;

    try {
        const caption =
            'üî¥ <b>‚åØ SESSION ENDED ‚åØ üî¥</b> \n' +
            '<b>‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</b>\n' +
            '‚û† Total Predictions: ' + sessionStats.predictions + '\n' +
            '‚û† Wins: ' + sessionStats.wins + '\n' +
            '‚û† Losses: ' + sessionStats.losses + '\n' +
            '‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'
        ;

        await sendTelegramPhoto(
            "https://i.ibb.co/5hhrYMSn/Picsart-25-11-23-19-27-32-782.png",
            caption
        );

        isSessionActive = false;
        localStorage.setItem('isSessionActive', 'false');
        updateSessionUI();
        showMessage('Session ended successfully!', 'success');

    } catch (error) {
        showMessage('Failed to end session: ' + error.message);
    }
}
    async function sendPredictionToTelegram(predictionData) {
        if (!isSessionActive) return false;

        const now = new Date();
        const currentDate = now.toLocaleDateString();
        const currentTime = now.toLocaleTimeString();

        // Format prediction message with better visual design using text characters
        const predictionMessage = `
‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìÜ <b>DAET‚û†</b> : ${currentDate}
‚è∞ <b>TIME ‚û†</b> : ${currentTime}
üé≤ <b>WINGO ‚û†</b> : 1 Minute
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚è≥ <b>ùó£·¥á Ä…™·¥è·¥Ö ‚û†</b> : ${predictionData.period}
üí• <b>ùó•·¥áÍú±·¥ú ü·¥õ  ‚û†</b> : ${predictionData.result}
üöÄ <b>ùóî·¥Ñ·¥Ñ·¥ú Ä·¥Ä·¥Ñ è ‚û†</b> : ${predictionData.probability}%
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 <i>       üîÆ ·¥© Ä·¥á·¥Ö…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ ·¥ã…™…¥…¢ üîÆ</i>
        `.trim();

        // Prepare inline keyboard if custom button is enabled
        let replyMarkup = null;
        if (botConfig.customButton.enabled && botConfig.customButton.title && botConfig.customButton.url) {
            replyMarkup = {
                inline_keyboard: [[
                    {
                        text: botConfig.customButton.title,
                        url: botConfig.customButton.url
                    }
                ]]
            };
        }

        try {
            // Send prediction as message
            const success = await sendTelegramMessage(
                predictionMessage,
                replyMarkup ? { reply_markup: replyMarkup } : {}
            );

            if (success) {
                sessionStats.predictions++;
                localStorage.setItem('sessionStats', JSON.stringify(sessionStats));
                updateSessionStats();
            }

            return success;
        } catch (error) {
            console.error('Failed to send prediction to Telegram:', error);
            return false;
        }
    }

    async function sendResultSticker(result) {
        if (!isSessionActive) return;

        const stickerId = result === 'WIN' 
            ? 'CAACAgUAAxkBAAEP2jRpIuQrQdApVkk7DqzjTtTfvX2w7AACvxgAAii5GVVndMKdNcg4AzYE'
            : 'CAACAgUAAxkBAAEP2jZpIuQuP55cIN-4MC0zqhdM5GUaRQACHhsAAox4GVUlEiT0pmD4bTYE';

        try {
            await sendTelegramSticker(stickerId);

            if (result === 'WIN') {
                sessionStats.wins++;
            } else {
                sessionStats.losses++;
            }
            
            localStorage.setItem('sessionStats', JSON.stringify(sessionStats));
            updateSessionStats();
        } catch (error) {
            console.error('Failed to send result sticker:', error);
        }
    }

    //---------------------------------------------------
    //  UI UPDATES
    //---------------------------------------------------
    function updateSessionUI() {
        const statusElement = document.getElementById('sessionStatus');
        const startBtn = document.getElementById('startSessionBtn');
        const endBtn = document.getElementById('endSessionBtn');

        if (isSessionActive) {
            statusElement.textContent = 'ACTIVE';
            statusElement.className = 'status-indicator status-active';
            startBtn.disabled = true;
            endBtn.disabled = false;
        } else {
            statusElement.textContent = 'INACTIVE';
            statusElement.className = 'status-indicator status-inactive';
            startBtn.disabled = false;
            endBtn.disabled = true;
        }
    }

    function updateSessionStats() {
        const statsElement = document.getElementById('sessionStats');
        statsElement.textContent = `Predictions Sent: ${sessionStats.predictions} | Wins: ${sessionStats.wins} | Losses: ${sessionStats.losses}`;
    }

    //---------------------------------------------------
    //  EVENT LISTENERS
    //---------------------------------------------------
    document.addEventListener('DOMContentLoaded', function() {
        // Tab navigation
        const tabs = document.querySelectorAll(".tab");
        const navItems = document.querySelectorAll(".nav-item");

        navItems.forEach(btn => {
            btn.addEventListener("click", () => {
                const targetTabId = btn.getAttribute("data-tab");

                navItems.forEach(b => b.classList.remove("active"));
                btn.classList.add("active");

                tabs.forEach(tab => {
                    if (tab.id === targetTabId) {
                        tab.classList.add("active");
                    } else {
                        tab.classList.remove("active");
                    }
                });
            });
        });

        // Clear history
        document.getElementById('clearHistoryBtn').addEventListener('click', function() {
            if (predictionHistory.length === 0) return;
            
            if (confirm("Are you sure you want to clear all prediction history?")) {
                predictionHistory = [];
                localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));
                renderHistory();
            }
        });

        // Bot configuration
        document.getElementById('enableCustomButton').addEventListener('change', toggleCustomButtonConfig);
        document.getElementById('saveConfigBtn').addEventListener('click', saveBotConfig);
        document.getElementById('startSessionBtn').addEventListener('click', startSession);
        document.getElementById('endSessionBtn').addEventListener('click', endSession);
        document.getElementById('testConnectionBtn').addEventListener('click', async function() {
            const btn = this;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            btn.disabled = true;

            try {
                const result = await testTelegramConnection();
                showMessage(result, 'success');
            } catch (error) {
                showMessage(error.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        });

        // Initialize app
        initializeApp();
    });

    // [REST OF THE PREDICTION FUNCTIONS - UNCHANGED]
    async function fetchLatestIssues(page = 1, size = 50) {
        try {
            const res = await fetch(
                "https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json" +
                    `?ts=${Date.now()}&page=${page}&size=${size}`,
                {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json"
                    }
                }
            );

            const data = await res.json();
            const list = data?.data?.list || [];
            return list;
        } catch (e) {
            console.error("fetchLatestIssues error:", e);
            return [];
        }
    }

    async function VisionMethod(preFetchedIssues) {
        let issueList = preFetchedIssues;
        if (!issueList || !Array.isArray(issueList) || issueList.length === 0) {
            issueList = await fetchLatestIssues(1, 50);
        }

        if (!issueList || issueList.length === 0) {
            throw new Error("No valid issue list available for prediction");
        }

        const data = issueList.map(item => ({
            resultNumber: item.number
        }));

        const numbers = data
            .map(item => {
                const num = parseInt(item.resultNumber, 10);
                return isNaN(num) ? 0 : num % 10;
            })
            .slice(0, 20);

        if (numbers.length < 5) {
            throw new Error("Insufficient data points for accurate prediction");
        }

        // Weighted Moving Average
        const weights = Array.from({ length: numbers.length }, (_, i) => i + 1);
        const weightedSum = numbers.reduce((sum, num, i) => sum + num * weights[i], 0);
        const weightSum = weights.reduce((sum, w) => sum + w, 0);
        const wma = weightedSum / weightSum;

        // Mean / StdDev
        const mean = numbers.reduce((s, n) => s + n, 0) / numbers.length;
        const stdDev =
            Math.sqrt(
                numbers.reduce((s, n) => s + Math.pow(n - mean, 2), 0) /
                    numbers.length
            ) || 0.0001;

        const upperBand = mean + 1.75 * stdDev;
        const lowerBand = mean - 1.75 * stdDev;

        const latest = numbers[0];
        const recentNumbers = numbers.slice(0, 5);

        // Trend
        const trend =
            recentNumbers[0] - recentNumbers[4] >= 1
                ? "up"
                : recentNumbers[4] - recentNumbers[0] >= 1
                ? "down"
                : "flat";

        let result;
        let probability;

        // Decision Logic BIG / SMALL
        if (latest > upperBand || (latest >= wma && trend === "up")) {
            result = "BIG";
        } else if (latest < lowerBand || (latest < wma && trend === "down")) {
            result = "SMALL";
        } else {
            result = latest >= 5 ? "BIG" : "SMALL";
        }

        // Probability estimation
        const deviation = Math.abs(latest - wma) / stdDev;
        probability = 82 + Math.min(deviation, 2) * 8.5;

        // Anti over-repetition
        if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
            result = result === "BIG" ? "SMALL" : "BIG";
            probability -= 8;
        }

        // Clamp probability
        probability = Math.min(99, Math.max(80, Math.round(probability)));

        return {
            result,
            probability
        };
    }

    function updateDisplayPeriodAndTimer() {
        const now = new Date();

        const seconds = now.getUTCSeconds();
        const minutes = now.getUTCMinutes();
        const hours = now.getUTCHours();

        let remainingSeconds = 60 - seconds;
        if (remainingSeconds === 60) remainingSeconds = 0;

        const totalMinutes = hours * 60 + minutes;

        const yyyy = now.getUTCFullYear();
        const MM = String(now.getUTCMonth() + 1).padStart(2, "0");
        const dd = String(now.getUTCDate()).padStart(2, "0");

        const dateStr = `${yyyy}${MM}${dd}`;
        const period =
            dateStr + "1000" + String(10001 + totalMinutes);

        displayPeriod = period;

        // UI update
        document.getElementById("period").innerText = displayPeriod;
        const formatted =
            `${String(0).padStart(2, "0")}:${String(remainingSeconds).padStart(
                2,
                "0"
            )}`;
        document.getElementById("countdown").innerText = formatted;

        return remainingSeconds;
    }

    async function runPrediction() {
        try {
            // 1) Get current latest issue on server
            const issuesBefore = await fetchLatestIssues(1, 10);
            const latestBefore = issuesBefore[0] || null;
            const refIssueNumber = latestBefore ? latestBefore.issueNumber : null;

            // 2) Run VisionMethod using same list
            const p = await VisionMethod(issuesBefore);

            // 3) Store BIG/SMALL history (for anti-repeat logic)
            lastResults.bigsmall.unshift(p.result);
            lastResults.bigsmall = lastResults.bigsmall.slice(0, 10);

            // 4) UI update
            document.getElementById("resultBox").innerText = p.result;
            document.getElementById("accuracy").innerText =
                p.probability + "% accuracy";

            // 5) Save to prediction history
            const historyEntry = {
                displayPeriod: displayPeriod,
                refIssue: refIssueNumber,
                resultIssue: null,
                predicted: p.result,
                probability: p.probability,
                status: "PENDING",
                apiResult: null
            };

            predictionHistory.unshift(historyEntry);
            localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));

            // 6) Send to Telegram if session is active
            if (isSessionActive) {
                const predictionData = {
                    period: displayPeriod,
                    result: p.result,
                    probability: p.probability,
                    number: 'Pending',
                    color: 'Pending'
                };
                
                await sendPredictionToTelegram(predictionData);
            }

            hasPendingVerification = true;
            renderHistory();
        } catch (e) {
            console.error("runPrediction error:", e);
            document.getElementById("resultBox").innerText = "Prediction Error";
            document.getElementById("accuracy").innerText = "Please try again";
        }
    }

    async function checkForResultVerification() {
        if (!hasPendingVerification) return;
        if (!predictionHistory.length) return;

        const pendingItem = predictionHistory.find(h => h.status === "PENDING");
        if (!pendingItem) {
            hasPendingVerification = false;
            return;
        }

        if (!pendingItem.refIssue) return;

        const issuesNow = await fetchLatestIssues(1, 10);
        if (!issuesNow.length) return;

        const latest = issuesNow[0];
        if (!latest || !latest.issueNumber) return;

        // Still same issue as prediction time -> result not rolled yet
        if (latest.issueNumber === pendingItem.refIssue) {
            return;
        }

        // Now we consider this "latest" issue as the result for our prediction
        const num = parseInt(latest.number, 10) % 10;
        const bigsmall = num >= 5 ? "BIG" : "SMALL";

        pendingItem.apiResult = bigsmall;
        pendingItem.resultIssue = latest.issueNumber;
        pendingItem.status =
            pendingItem.predicted === bigsmall ? "WIN" : "LOSS";

        // Send result sticker to Telegram if session is active
        if (isSessionActive && pendingItem.status !== "PENDING") {
            await sendResultSticker(pendingItem.status);
        }

        hasPendingVerification = false;
        
        // Save to localStorage
        localStorage.setItem('predictionHistory', JSON.stringify(predictionHistory));
        
        renderHistory();
    }

    function renderHistory() {
        const box = document.getElementById("historyList");

        if (!predictionHistory || predictionHistory.length === 0) {
            box.innerHTML = `
                <div class="empty-history">
                    <i class="fas fa-history"></i>
                    <p>No predictions yet</p>
                </div>
            `;
            return;
        }

        box.innerHTML = predictionHistory
            .map(item => {
                return `
                <div class="history-item ${item.status.toLowerCase()}">
                    <div class="history-item-header">
                        <div class="history-period">${item.displayPeriod}</div>
                        <div class="history-status ${item.status.toLowerCase()}">${item.status}</div>
                    </div>
                    <div class="history-details">
                        <div class="history-detail-item">
                            <span class="history-detail-label">Prediction:</span>
                            <span class="history-detail-value">${item.predicted} (${item.probability}%)</span>
                        </div>
                        <div class="history-detail-item">
                            <span class="history-detail-label">Reference Issue:</span>
                            <span class="history-detail-value">${item.refIssue || 'N/A'}</span>
                        </div>
                        ${item.resultIssue ? `
                        <div class="history-detail-item">
                            <span class="history-detail-label">Result Issue:</span>
                            <span class="history-detail-value">${item.resultIssue}</span>
                        </div>
                        ` : ''}
                        ${item.apiResult ? `
                        <div class="history-detail-item">
                            <span class="history-detail-label">Actual Result:</span>
                            <span class="history-detail-value">${item.apiResult}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
            })
            .join("");
    }

    //---------------------------------------------------
    //  MAIN LOOP
    //---------------------------------------------------
    async function mainTick() {
        const remainingSeconds = updateDisplayPeriodAndTimer();

        // Fire prediction exactly when new minute starts:
        // When remainingSeconds goes from something else to 59
        if (remainingSeconds === 59 && lastSecond !== 59) {
            await runPrediction();
        }

        lastSecond = remainingSeconds;

        await checkForResultVerification();
    }

    // Initialize the app
    setInterval(mainTick, 1000);
    mainTick(); // initial
    renderHistory(); // initial render of history
</script>
</body>
</html>